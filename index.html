<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>The End of Unsafety</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <link rel="stylesheet" href="css/eou.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal eou">
      <div id="slide-name"></div>
      <div class="slides">

        <!-- Introduction -->

        <section id="INTRO" class="noid">
          <h1>The End of Unsafety</h1>
          <hr>
          <h2>The Past, Present and Future</h2>
          <sup>of</sup>
          <h2>The Rust Programming Language</h2>

          <aside class="notes">
            <p>Hello and thank you for joining us for this talk. We
            are honored to be here in Beijing for the first time.</p>

            <p>This is The End of Unsafety.</p>
          </aside>
        </section>

        <section id="BARB" class="noid"
                 data-background-image="images/barbarians.jpg">

          <aside class="notes">
            <p>We live in an Age of Unsafety.</p>

            <p>This age began in <em>1972</em>, with the <em>C</em>
            language, and with <em>Unix</em>, and today it encompasses
            all that we see. Unsafety is at the foundation of the
            computing world.</p>

            <p>And now we are beset on all sides. The barbarians are
            at the gate.</p>

            <p>The internet is no longer safe, and the tools of the
            past are no longer up to the task of securing it.</p>

            <p>That is why Rust exists.</p>
          </aside>
        </section>

	<section id="WHO" style="height: 100%;">
          <img src="images/rust-logo-white.svg"
               style="height: 50%;">
          <div id="nametable">
            <div>Brian Anderson<br><small>&lt;banderson@mozilla.com&gt;</small></div>
            <div>Alex Crichton<br><small>&lt;acrichton@mozilla.com&gt;</small></div>
          </div>

          <aside class="notes">
            <p>My name is Brian Anderson, and this is my friend Alex
            Crichton, and we are both on the core team of the Rust
            programming language, as well as being employed to work on
            Rust by Mozilla Research.</p>

            <p>Alex will you introduce yourself?</p>

            <p>Alex: I've been working on Rust since 2013, where I
              have been responsible for large portions of the standard
              library and the broader library ecosystem. I'm also
              etc.</p>

            <p>Brian: I've been working on Rust since 2010, involved
            in every aspect of its development. Much of my work has
            been in the standard library, tooling, platform support,
            community building. I have a special passion for software
            validation and ensuring that Rust is rock solid from
            release to release.</p>
          </aside>
        </section>

        <section id="LINK">
          <p>https://github.com/brson/the-end-of-unsafety</p>
          <br>
          <p>~&#x2000; slides, notes, links &#x2000;~</p>

          <aside class="notes">
            <p>Here's the link to the materials for this talk. It
            includes the slides, speaker notes, and plenty of
            links.</p>

            <p>I'll give you just a few seconds to make note if you
            like.</p>

            <p>(take a drink)</p>

            <p>We're going to talk a lot about Rust later, but the
            first part of this talk is mostly about the motivation for
            Rust. Before we get into that though, a little bit about
            what Rust is.</p>
          </aside>
        </section>

        <section id="WHAT" data-transition="slide-in fade-out" data-transition-speed="fast">
          <h3>Rust</h3>
          <ul>
            <li>Top-tier performance &#x2000; <span>(like C/C++ or better)</span></li>
            <li>Memory safe &#x2000; <span>(no crashes)</span></li>
            <li>No runtime, no GC &#x2000; <span>(runs everywhere)</span></li>
            <li>Targets the same use cases as C/C++ &#x2000; <span>(all of them)</span></li>
            <li>Sponsored by Mozilla &#x2000; <span>(makers of Firefox)</span></li>
          </ul>
          <br><br>
          <p>~&#x2000; www.rust-lang.org &#x2000;~</p>

          <aside class="notes">
            <p>Rust is first and foremost
            a <em>high-performance</em>, <em>memory safe</em>, systems
            programming language. And when I say "high-performance", I
            don't just mean it's fast, I mean it's among the very
            fastest programming languages. <em>Think C, C++, and
            Fortran</em>.</p>

            <p>And when I say "memory safe" I mean that Rust software
            does not crash, at least not in the way that languages
            like C and C++ do, where a crash can lead to
            unpredictable, and - most importantly - exploitable
            behavior.</p>

            <p><em>Rust provides the very best performance without
            sacrificing safety</em>.</p>

            <p>It accomplishes this by being designed completely
            around safe, <em>zero-cost abstractions</em>. The code you
            write corresponds quite directly to the code the machine
            runs. Accordingly, Rust has <em>no runtime</em>, and -
            crucially - <em>no garbage collector</em>. And this makes
            Rust extremely <em>portable</em> - Rust will run on just
            about anything with a CPU, everything from
            <em>microcontrollers</em> to <em>supercomputers</em>.</p>

            <p>Rust is a thriving, collaboratively developed <em>open
            source</em> project sponsored by <em>Mozilla</em>, the
            makers of <em>Firefox</em>, who employ Alex and myself.</p>
          </aside>
        </section>

	<section id="OV" data-transition="none">
          <h3>Timeline of the End of Unsafety</h3>
          <div class="timeline">
            <div>
              <span class="x"></span>
              <span class="x"></span>
              <span class="x"><span class="x small"></span></span>
            </div>
            <p>&nbsp;</p>
          </div>

          <aside class="notes">
            <p>Here's an overview of what this talk is about.</p>
          </aside>
        </section>

	<section id="OV1" data-transition="none">
          <h3>The Age of Unsafety</h3>
          <div class="timeline">
            <div>
              <span class="x"></span>
              <span></span>
              <span><span></span></span>
            </div>
            <p>1972 &nbsp; → &nbsp; whenever</p>
          </div>

          <aside class="notes">
            <p>First we're going to visit The Age of Unsafety, in
            which C was conceived, and the entire computing world we
            know was built on top of it.</p>
          </aside>
        </section>

	<section id="OV2" data-transition="none">
          <h3>The Creation of Rust</h3>
          <div class="timeline">
            <div>
              <span></span>
              <span class="x"></span>
              <span><span></span></span>
            </div>
            <p>2009 &nbsp; → &nbsp; present</p>
          </div>

          <aside class="notes">
            <p>Then we're going to visit Rust's history, why Mozilla
            created it, and how Rust evolved to provide solutions for
            the use cases commonly reserved for C and C++ alone.</p>

            <p>We'll also explain the technique that makes Rust so
            powerful, called "ownership and borrowing".</p>
          </aside>
        </section>

	<section id="OV3" data-transition="none">
          <h3>Rust Today</h3>
          <div class="timeline">
            <div>
              <span></span>
              <span></span>
              <span><span class="x"></span></span>
            </div>
            <p>right now!</p>
          </div>

          <aside class="notes">
            <p>With that context, then we will try to convince you
            that Rust is really exciting right now.</p>
          </aside>
        </section>

	<section id="OV4" data-transition="none">
          <h3>The Future of Rust</h3>
          <div class="timeline">
            <div>
              <span></span>
              <span></span>
              <span class="x"><span></span></span>
            </div>
            <p>present &nbsp; → &nbsp; the glorious future</p>
          </div>

          <aside class="notes">
            <p>Then we'll speculate about the coming years for Rust,
            and the end of unsafety.</p>
          </aside>
        </section>

        <section id="D">
          Disclaimers

          <aside class="notes">
            A quick disclaimer. In the Rust project we take
            great <em>pride</em> in being
            <em>civil</em>, in not putting down the competition. But
            Rust is a <em>direct competitor</em> to C and C++ in the
            marketplace, and this talk will say much about the
            <em>weaknesses of C and C++</em> in comparison to Rust. As
            former C and C++ programmers ourselves we have the
            greatest <em>respect</em> for their users and
            creators. We'll try to stick to the <em>facts</em>, and we
            beg your forgiveness if we misspeak. Toward the end of
            this talk we'll discuss some of <em>Rust's own
            weaknesses</em>.
          </aside>
        </section>

        <!-- The Age of Unsafety -->

	<section>
          <h3>The Age of Unsafety</h3>
          <div class="timeline">
            <div>
              <span class="x"></span>
              <span></span>
              <span><span></span></span>
            </div>
            <p>1972 &nbsp; → &nbsp; whenever</p>
          </div>
        </section>

        <section class="e0">
          <h3>What is "<span style="color: red;">unsafe</span>"?</h3>
        </section>

        <section id="MEM">
          <h3>Memory safety</h3>

          <blockquote>
            The state of being protected from various software bugs
            and security vulnerabilities when dealing with memory
            access, such as buffer overflows and dangling pointers.
          </blockquote>
          <cite>&mdash; Wikipedia</cite>
        </section>

        <section id="MEMERR">
          <h3>Memory safety errors</h3>
          <ul>
            <li>Buffer overflow</li>
            <li>Stack overflow</li>
            <li>Use after free</li>
            <li>Double free</li>
            <li>Data races</li>
            <li>Segmentation fault</li>
          </ul>
        </section>

        <section>
          <h3>Why keep using C/C++?</h3>

          <ul>
            <li>Inertia</li>
            <li>Costly to rewrite</li>
            <li>Portability</li>
          </ul>
        </section>

        <section>
          <blockquote>
            Let's
            be <span id="honest"><span>honest</span><span class="fragment">honest</span></span>,
            if you need segfault protection, you're a bad programmer.
          </blockquote>
          <cite>&mdash; Anonymous good<br>programmer<br>on the internet</cite>
        </section>

        <section id="OSSL">
          <h3>A real-world example</h3>
          OpenSSL
        </section>

        <section>
          <img src='images/heartbleed.png'/>
        </section>

        <section>
          <h3>Heartbleed in detail</h3>
          <ul>
            <li>Missing bounds check</li>
            <li>Dormant for <strong>two years</strong></li>
            <li>Private keys leaked</li>
          </ul>
        </section>

        <section>
          <img src='images/stagefright.png'/>
        </section>

        <section>
          <img src='images/conficker.png' style='background:white'/>
        </section>

        <section>
          <img src='images/curl.svg' style = 'background:white;padding:50px'/>
        </section>

        <section>
          <h3>CVE-2015-7547</h3>
          <ul>
            <li>glibc: getaddrinfo stack-based buffer overflow</li>
            <li>Multiple stack-based buffer overflows</li>
          </ul>
        </section>

        <section>
          <img src='images/cves.png' style = 'background:white;padding:50px'/>
        </section>

        <!-- The Creation of Rust -->

	<section id="CREAT">
          <h3>The Creation of Rust</h3>
          <div class="timeline">
            <div>
              <span></span>
              <span class="x"></span>
              <span><span></span></span>
            </div>
            <p>2009 &nbsp; → &nbsp; present</p>
          </div>

          <aside class="notes">
            <p>So now we're going to get to Rust.</p>

            <p>In <em>2009 Brendan Eich</em>, the <em>creator of
            JavaScript</em>, and <em>co-founder of Mozilla</em>, was
            thinking about these problems a lot, and <em>despairing</em>.</p>
          </aside>
        </section>

        <section id="FX" style="width: 80%; height: 80%;">
          <img src="images/firefox.png"
               style="height: 100%;">

          <aside class="notes">
            <em>Firefox</em>, the web browser he had helped create,
            with <em>over 100 million users</em>, was in trouble.

            <em>Web browsers are massive pieces of software</em>,
            exposed directly to the internet, and <em>constantly under
            attack</em>.
          </aside>
        </section>

        <section id="BLOC">
          <div>
            <div>
              <img src="images/firefox.png" style="height: 200px;">
            </div>
            <div><span>10,000,000 LOC</span></div>
          </div>
          <div>
            <div>
              <img src="images/chrome.svg" style="height: 150px;">
            </div>
            <div><span>12,000,000 LOC</span></div>
          </div>

          <aside class="notes">
            This gives you an idea of the <em>size of the Firefox
            codebase</em>: 10 million lines. And Chrome is even bigger
            at 12 millions lines. They <em>aren't the biggest code
            bases in the world</em>, but they are big. And this is
            <em>just the parts written in C and C++</em>. Any one of
            these lines of <em>code could be hiding a bug that leads
            to an exploit</em>.
          </aside>
        </section>

        <section id="BCVE">
          <div>
            <div>
              <img src="images/firefox.png" style="height: 200px;">
            </div>
            <div><span>133 CVEs in 2016</span></div>
          </div>
          <div>
            <div>
              <img src="images/chrome.svg" style="height: 150px;">
            </div>
            <div><span>203 CVEs in 2016</span></div>
          </div>

          <aside class="notes">
            And they do. All the time. Firefox had more than 130 CVEs
            in 2016.  Not all of these were due to memory unsafety,
            but a lot were. We find that when we do that analysis
            that <em>anywhere from 20%, to 50% or more</em> of CVEs
            for any particular product are due to memory unsafety.
          </aside>
        </section>

        <section id="WEBAUD">
          <blockquote>
            All 34 sec-critical bugs filed against Web Audio so far
            are either buffer overflows or use-after-free.
          </blockquote>
          <cite>&mdash; Robert O'Callahan, Mozilla</cite>

          <aside class="notes">
            This is a <em>quote from Robert O'Callahan</em>, a
            <em>distinguished Mozilla engineer</em>, from 2013, about
            the Web Audio stack. The Web Audio stack is a large C++
            codebase and when it was introduced to Firefox, it brought
            along with it 34 critical security bugs, <em>100% of
            which</em> were due to memory unsafety.
          </aside>
        </section>

        <section id="RUST" style="height: 80%;">
          <img src="images/rust-logo-white.svg" style="height: 100%;">

          <aside class="notes">
            So Brendan was worried about this in 2009, and started talking with
            his peers about finding solutions. And it just so happened that
            <em>Graydon Hoare</em> had a <em>pet project</em> that was
            <em>intented to solve</em> these problems. Graydon had
            previously been involved in the doomed <em>ECMAScript
            4</em> effort, and before that had created
            the <em>Monotone version control system</em>. And now he
            was <em>working on a programming language called
            "Rust"</em>.
          </aside>
        </section>

        <section id="DORIG">
          <h3>Rust's original design / requirements</h3>
          <div>
            <ul style="position: absolute; top=0; left=0;">
              <li>Memory safety</li>
              <li>Thread-local, garbage-collected heaps</li>
              <li>Green-threaded concurrency (ala Go)</li>
            </ul>
            <ul class="fragment">
              <li>Memory safety</li>
              <li><strike>Thread-local, garbage-collected heaps</strike></li>
              <li><strike>Green-threaded concurrency (ala Go)</strike></li>
            </ul>
          </div>

          <aside class="notes">
            <p>Now, the Rust of 2009 was much different from the Rust
            of today. But even then, the <em>primary objective was to
            solve the memory safety problem</em>, but the assumptions were
            different.</p>

            <p>Back then, even the Rust team thought the <em>only
            viable way to solve the memory safety problem was through
            a garbage collector</em>, so Rust's heaps were garbage
            collected, but that garbage collection
            was <em>thread-local</em>.  That way garbage collection in
            one thread would not <em>interfere with progress</em> in
            other threads. This was in <em>important early
            constraint</em>, and it influenced our ultimate
            solution.</p>

            <p>Rust was, at the time, a <em>green-threaded</em>
            programming language in the style of Go, with ML
            influences.</p>

            <p>(next fragment)</p>

            <p>But these assumptions did not hold.</p>
          </aside>
        </section>

        <section id="DACT">
          <h3>Rust's actual design / requirements</h3>
          <ul>
            <li>Memory safety</li>
            <li>Ultimate performance</li>
            <li>No GC or runtime at all</li>
            <li>Traditional OS threads and concurrency</li>
          </ul>

          <aside class="notes">
            <p>And the reason that both these original assumptions
            didn't hold boils down to <em>performance</em> - for our
            use cases we can <em>tolerate no runtime abstraction
            costs</em>, and both garbage collection and
            green-threading impose significant overhead.</p>

            <p>But it took us a <em>long time</em> to come to
            this <em>conclusion</em>, and we only came to it
            <em>indirectly</em>. For a long time we thought these
            costs would be acceptable - it was only after reaching an
            important <em>insight</em> about the design of Rust that
            we realized not only the <em>importance</em>
            of <em>zero-cost abstractions</em>, but also
            the <em>attainability</em> of zero-cost abstractions.</p>
          </aside>
        </section>

        <section id="KEY">
          <h3>Rust's key design problem</h3>

          <p>How can I maintain memory safety in a concurrent program
             without a global GC?</p>

          <aside class="notes">
            <p>And the key question that drove that insight was this:</p>

            <p>"How can I maintain memory safety in a concurrent
              program without a global GC?"</p>
          </aside>
        </section>

        <section id="HEAP">
          <div class="twoheap">

            <div>
              <div>Thread A</div>
              <div class="heap">
                <span>h<br>e<br>a<br>p</span>
                <img src="images/balloon-blue.png" class="fragment" id="balloon-orig">
              </div>
              <div class="stack">
                <span>s<br>t<br>a<br>c<br>k</span>
              </div>
            </div>

            <div>
              <div>Thread B</div>
              <div class="heap">
                <span>h<br>e<br>a<br>p</span>
                <img src="images/balloon-blue.png" class="fragment" id="balloon-transfer">
              </div>
              <div class="stack">
                <span>s<br>t<br>a<br>c<br>k</span>
              </div>
            </div>

          </div>

          <aside class="notes">
            <p>Let me illustrate the problem. Here we have <em>two
            isolated threads</em>, each with its own <em>heap</em> (on top),
            and <em>stack</em> (on bottom).</p>

            <p>Now, imagine I create an object in thread A's heap.</p>

            <p>(next fragment)</p>

            <p>Here represented by a blue balloon.</p>

            <p>Now, imagine that thread B wants that balloon, so I
            send it from thread A to thread B.</p>

            <p>(next fragment)</p>

            <p>So far so good. But how should the language actually
            implement that? Well, since the Rust of 2009 had isolated
            heaps, perhaps we make a <em>deep copy</em> of the
            balloon, copying the balloon over to the other heap.</p>

            But what if the balloon itself contains <em>pointers to
            other ballons</em>? And what if one of those contains a
            <em>pointer back into the stack</em>? How do you deal with
            those?

            <p>These are hard problems to solve, and it's easy to end up back in a
            situation like this...</p>
          </aside>
        </section>

        <section id="TANGLE">
          <div class="twoheap">

            <div>
              <div>Thread A</div>
              <div class="heap">
                <span>h<br>e<br>a<br>p</span>
              </div>
              <div class="stack">
                <span>s<br>t<br>a<br>c<br>k</span>
              </div>
            </div>

            <div>
              <div>Thread B</div>
              <div class="heap">
                <span>h<br>e<br>a<br>p</span>
              </div>
              <div class="stack">
                <span>s<br>t<br>a<br>c<br>k</span>
              </div>
            </div>

          </div>
          <img src="images/balloon-tangled.png">

          <aside class="notes">
            <p>With pointers from multiple threads pointing into the same objects.</p>

            <p>And then we need a global GC again.</p>
          </aside>
        </section>

        <section id="INS">
          The Rust insight
          <p class="fragment">Rust is Cyclone + Singularity</p>

          <aside class="notes">
            <p>For months we batted around this <em>problem</em>
            of <em>sending objects</em> between threads
            without <em>invalidating pointers</em>, and without a
            <em>garbage collector</em>.</p>

            <p>Around this time <em>Niko Matsakis</em> joined the
            team. Niko was an actual trained <em>type theorist</em>,
            and he brought some good ideas.</p>

            <p>Niko was looking at a research project called <em>Cyclone</em>
            and wondering if we could learn from it. Cyclone was a
            safe dialect of C that used <em>static analysis</em> to track the
            validity of pointers.</p>

            <p>Cyclone's system was somewhat limited and did not directly solve
            our multithreading problem.</p>

            <p>But also at the same time we became aware of another
            research project at Microsoft
            called <em>Singularity</em>. It was an attempt to
            reimagine the operating system in .NET. There wasn't a lot
            of information coming out of Microsoft but what caught our
            eye was their <em>approach to concurrency</em>. In
            Singularity they employed a novel technique
            to <em>transfer ownership</em> of - and <em>sole
            access</em> to - <em>entire regions of memory</em> between threads,
            by only <em>copying a pointer</em>.</p>

            <p>(next fragment)</p>

            <p>In a real sense Rust is Cyclone plus Singularity.</p>

            <p>And the result in Rust is what we call "<em>ownership and borrowing</em>".</p>
          </aside>
        </section>

        <section id="OWN">
          <h3>Ownership and borrowing</h3>
          <p>In Rust, every value has a single, statically-known,
            owning path in the code, at any time.</p>
          <p>Pointers to values have limited duration, known as a
            "lifetime", that is also statically tracked.</p>
          <p>All pointers to all values are known statically.</p>

          <aside class="notes">
            <p>This is kind of the key takeaway of this whole presentation. Ownership
            and borrowing is what makes Rust, Rust.</p>

            <p>(read the slide verbatim)</p>

            <p>Now there are actually are caveats and exceptions, but
            if you understand this, you understand how Rust approaches
            the memory safety problem.</p>
          </aside>
        </section>


        <section id="BAL">
          <img src="images/balloons.png" style="height: 500px;">

          <aside class="notes">
            <p>One of the neat things about ownership and borrowing as
            a computational model, is that the <em>concepts are
            familiar</em> and natural. Ownership and borrowing in Rust
            is similar to ownership and borrowing of <em>physical
            objects</em>.</p>

            <p>So this is the portion of the talk where Alex and I
            usually do a live demonstration of balloon
            borrowing. Unfortunately, I failed to acquire the
            necessary helium yesterday, so we're going to demonstrate
            virtually instead.</p>
          </aside>
        </section>

        <section id="BOWN">
          <div class="stickarea">
            <div id="stick-title-owned">Move an owned value</div>
            <img src="images/stick-boy-down.png" class="b" id="boy-owned">
            <img src="images/stick-girl-down.png" class="g" id="girl-owned">
            <img src="images/balloon-blue.png" class="o" id="balloon-owned">
            <div class="dialog" id="balloon-owned-di">OK, give my<br>balloon back</div>
          </div>
          <div class="fragment" style="display: none" id="balloon-owned-trigger1"/>
          <div class="fragment" style="display: none" id="balloon-owned-trigger2"/>
          <div class="fragment" style="display: none" id="balloon-owned-trigger3"/>
          <div class="fragment" style="display: none" id="balloon-owned-trigger4"/>

          <aside class="notes">
            <p>First we'll demonstrate <em>transfer of ownership</em>.</p>

            <p>Here I have two figures, stickboy and stickgirl, and
            they love balloons.</p>

            <p>(next)</p>

            <p>Stickboy has a beautiful blue balloon, and stickgirl
            wants that balloon. So stickboy is going to hand the
            balloon to stickgirl.</p>

            <p>(next)</p>

            <p>Oh she's real excited about that balloon, but stickboy
            is going to want it back.</p>

            <p>(next)</p>

            <p>But stickboy doesn't really have any agency here,
            because he gave that balloon to stickgirl. And she can do
            whatever she wants with it.</p>

            <p>(next)</p>
          </aside>
        </section>

        <section id="BSH">
          <div class="stickarea">
            <div id="stick-title-sh">Borrow a shared reference (&)<br></div>
            <img src="images/stick-boy-up.png" class="b" id="boy-sh">
            <img src="images/stick-girl-down.png" class="g" id="girl-sh">
            <img src="images/balloon-green-nostring.png" id="balloon-sh">
            <img src="images/balloon-string.png" id="string-sh">
          </div>
          <div class="fragment" style="display: none" id="balloon-sh-trigger1"/>
          <div class="fragment" style="display: none" id="balloon-sh-trigger2"/>

          <aside class="notes">
            <p>If stickboy wanted to keep his balloon what he really
            should have done was have her <em>borrow a reference</em> to
            it, indicated in Rust by the ampersand.</p>

            <p>So here let's watch stickboy hand his green balloon to
            stickgirl.</p>

            <p>(next)</p>

            <p>This time, he's handing her the balloon, but holding
            onto it himself. So when she's done peeking at it stickboy
            can just pull it right back.</p>

            <p>(next)</p>

            <p>This type of reference is called a "<em>shared reference</em>",
            and it's immutable, but there's one more type of reference
            in Rust.</p>
          </aside>
        </section>

        <section id="BMUT">
          <div class="stickarea">
            <div id="stick-title-mut">Borrow a mutable reference (&mut)</div>
            <img src="images/stick-boy-up.png" class="b" id="boy-mut">
            <img src="images/stick-girl-down.png" class="g" id="girl-mut">
            <img src="images/balloon-red-nostring.png" id="balloon-mut">
            <img src="images/balloon-string.png" id="string-mut">
            <img src="images/pop.png" id="pop">
          </div>
          <div class="fragment" style="display: none" id="balloon-mut-trigger1"/>
          <div class="fragment" style="display: none" id="balloon-mut-trigger2"/>
          <div class="fragment" style="display: none" id="balloon-mut-trigger3"/>
          <div class="fragment" style="display: none" id="balloon-mut-trigger4"/>

          <aside class="notes">
            <p>The <em>mutable reference</em>, indicated by ampersand
            "mute".</p>

            <p>In this example stickboy is going to pass the balloon
            to stickgirl.</p>

            <p>(next)</p>

            <p>And because it's a mutable reference, she can not only
            examine it, but can mutate it as well.</p>

            <p>(next)</p>

            <p>So she's going to draw a cheerful face on stickboy's balloon.</p>

            <p>(next)</p>

            <p>And after stickboy yanks it back, while he's still in
            possession of his treasured red balloon, it's been
            modified.</p>

            <p>Since he still owns the balloon though, he's free to do
            what he wants with it, including destroy it.</p>

            <p>(next)</p>
          </aside>
        </section>

        <section id="ROWN">
          <div>Move an owned value</div>
          <pre><code data-trim data-noescape>
fn main() {
    let b = Balloon::new();
    examine_balloon(b);
    <span class="fragment">// accessing b here is a compilation error
    <span id="rown-error">println!("still have a balloon? {}", b);</span></span>
}

fn examine_balloon(b: Balloon) {
    println!("this balloon looks like {}", b);
    // b is destroyed when the function exits
}
          </code></pre>
          <div class="fragment" id="rown-trigger"/>
        </section>

        <section id="RSH">
          <div>Borrow a shared reference (<span class="rsh-em">&</span>)</div>
          <pre><code data-trim data-noescape>
fn main() {
    let b = Balloon::new();
    examine_balloon(<span class="rsh-em">&</span>b);
    println!("still have my balloon! {}", b);
    // b is destroyed when the function exits
}

fn examine_balloon(b: <span class="rsh-em">&</span>Balloon) {
    println!("this balloon looks like {}", b);
}
          </code></pre>
          <div class="fragment" style="display: none" id="rsh-trigger"/>
        </section>

        <section id="RMUT">
          <div>Borrow a mutable reference (<span class="rmut-em">&mut</span>)</div>
          <pre><code data-trim data-noescape>
fn main() {
    let <span class="rmut-em">mut</span> b = Balloon::new();
    examine_balloon(<span class="rmut-em">&mut</span> b);
    println!("still have my balloon! {}", b);
    // b is destroyed when the function exits
}

fn examine_balloon(b: <span class="rmut-em">&mut</span> Balloon) {
    b.draw(Drawing::HappyFace);
}
          </code></pre>
          <div class="fragment" style="display: none" id="rmut-trigger"/>
        </section>

        <section id="SUM">
          <h3>Ownership and borrowing operations</h3>
          <ul>
            <li>Move an owned value</li>
            <li>Borrow a shared reference (&T)</li>
            <li>Borrow a mutable reference (&mut T)</li>
          </ul>

          <aside class="notes">
            <p>Here's a summary of ownership and borrowing.</p>

            <p>This is how Rust sees everything. A convenient way to
            think of this is that Rust <em>shared and mutable
            references</em> provide <em>reader-writer locks</em>
            over <em>owned values</em>. Rust has built-in <em>access
            control</em> to all memory, and it is completely determined
            statically, with no runtime overhead.</p>

            <p>This control enables Rust's powerful <em>zero-cost
            abstractions</em>, and its <em>incredible
            performance</em>.</p>

            <p>Now Alex is going to tell you what we've accomplished
            with it.</p>
          </aside>
        </section>

        <!-- Rust Today -->

	<section>
          <h3>Rust Today</h3>
          <div class="timeline">
            <div>
              <span></span>
              <span></span>
              <span><span class="x"></span></span>
            </div>
            <p>right now!</p>
          </div>
        </section>

        <!--
        <section>
          Performance goals achieved
        </section>
        -->

        <section>
          <h3>Best-in-class performance</h3>
          <ul>
            <li>ripgrep - 8x faster than grep</li>
            <li>webrender - hundreds of fps</li>
          </ul>
        </section>

        <section>
          <h3>Stability as a deliverable</h3>
          <ul>
            <li>Stable since 2015</li>
            <li>16 point releases</li>
            <!--
              Growing library ecosystem
              Open governance, RFC process
            -->
          </ul>
        </section>

        <!--
        <section>
          Stability guarantees
        </section>
        -->

        <section>
          <h3>Growing library ecosystem</h3>
          <ul>
            <li>9k crates</li>
            <li>50k versions</li>
            <li>150M downloads</li>
          </ul>
        </section>

        <section>
          <h3>Rust's Community</h3>
          <ul>
            <li>1967 contributors to rust-lang/rust</li>
            <li>RustConf, RustFest, Rust Belt Rust</li>
          </ul>
        </section>

        <!--
        <section>
          What people are saying
        </section>
        -->

        <section>
          StackOverflow 2017 Survey results
          <img src='images/most-loved.png' />
        </section>

        <section>
          RedMonk Language Rankings

          <blockquote>
            By our metrics, Rust went from the 46th most popular language on
            GitHub to the 18th... no other language grew faster.
          </blockquote>
        </section>

        <!--
        <section>
          Some glowing quote
        </section>
        -->

        <!--
        <section>
          Fast, Reliable, Productive
        </section>
        -->

        <section>
          <a href='https://www.rust-lang.org/friends.html'>
            https://www.rust-lang.org/friends.html
          </a>
          <img src='images/friends.png' style='height:500px'/>
        </section>

        <!-- The Future of Rust -->

	<section id="SFUT">
          <h3>The Future of Rust</h3>
          <div class="timeline">
            <div>
              <span></span>
              <span></span>
              <span class="x"><span></span></span>
            </div>
            <p>present &nbsp; → &nbsp; the glorious future</p>
          </div>

          <aside class="notes">
            <p>So hopefully by now we've painted a fairly glowing
            picture of Rust. But that's not to say that Rust is
            perfect. We've got a long way to go yet.</p>

            <p>In this portion we'll talk first about some
            the <em>challenges</em> Rust faces, and some if its
            <em>deficiencies</em>. Then we'll say a bit about the
            future direction of Rust, and the future of unsafety.</p>
          </aside>
        </section>

        <section id="CHAL">
          <h3>Rust soft challenges</h3>
          <ul>
            <li>Acceptance / learning curve</li>
            <li>Competition from other languages</li>
          </ul>

          <aside class="notes">
            <p>So we think Rust is in a <em>very strong position</em>
            right now. It has <em>qualities</em> that no other
            language stack has, and that are not easy to achieve. But
            Rust's long-term success is <em>not yet guaranteed</em>,
            and it's adoption, while growing quickly, is still
            modest.</p>

            <p>A big challenge is Rust's <em>learning
            curve</em>. While Rust has a reasonably <em>familiar
            syntax</em> to C++ programmers, it's semantics are just as
            much derived from <em>ML and Haskell</em>. We believe
            Rust's semantics are quite attractive for systems
            programmers, but convincing happy C++ developers of this
            isn't simple.</p>

            <p>But more than that, Rust's fundamental model -
            <em>ownership and borrowing</em> - is effectively
            a <em>new programming paradigm</em> - it requires users to
            adapt to a <em>new way of thinking</em> about how they
            manage the resources in their code. Programmers who make
            that connection tend to find the Rust model significantly
            <em>clarifiies their own thinking</em> about code, but it
            does take <em>investment</em> on the programmers part, and an
            <em>openness</em> to new ideas.</p>

            <p>It's also possible that plain competition could win
            over Rust. In much the same way C, a "worse is better"
            solution, dominated the market for decades by working in
            all the right places, some other language may do what Rust
            does just good enough. Or a new language might do Rust
            better than Rust.</p>
          </aside>
        </section>

        <section id="CHCPP">
          <h3>Challenges for Rust replacing C++</h3>
          <ul>
            <li>C++ language interop</li>
            <li>Build system integration</li>
          </ul>

          <aside class="notes">
            <p>We think Rust is an excellent C++ replacement
            today. Both languages have <em>similar costs and
            performance</em>, but Rust has the advantage of <em>memory
            safety and a clean slate</em>.</p>

            <p>The biggest challenge to Rust's adoption in the systems
            space is <em>interoperating</em> with the vast amounts of
            C++ code running the world today. Note that I say "C++"
            and not "C and C++". Interop with C is quite simple and
            Rust can masquerade as C all day. Interop with C++ on the
            other hand is very, very hard, and few languages do it
            successfully.</p>

            <p>Along those same lines, we've already encountered a
            number of challenges integrating Rust into <em>existing
            build systems</em>. Rust has it's own opinionated package
            manager called Cargo, and while it works very well,
            teaching it to integrate with all the various build
            systems used for C and C++ is an ongoing process. This is
            something we're hearing a lot from users right now, and
            working to address.</p>
          </aside>
        </section>

        <section id="CHC">
          <h3>Challenges for Rust replacing C</h3>
          <ul>
            <li>ABI stability &#x2000; <span>(upgradable dlls)</span></li>
            <li>Monomorphization &#x2000; <span>(binary bloat)</span></li>
            <li>Unstructured control flow &#x2000; <span>(setjmp / longjmp, goto)</span></li>
          </ul>

          <aside class="notes">
            <p>Rust replacing C is in some ways a simpler story than
            replacing C++, and some ways more complex. <em>C is a much
            easier language to interop with than C++</em>, and because
            of that it tends to be used for the <em>lowest layers</em>
            of the stack, in <em>system libraries</em>
            and <em>operating system kernels</em>.</p>

            <p>The big thing that Rust needs to make inroads at that
            level is <em>ABI stability</em> - that is, the capacity to do
            seamless upgrades of dynamic libraries between point
            releases. Today Rust provides very strong <em>source
            stability</em>, but not <em>binary stability</em>.</p>

            <p>Another significant technical challenge for Rust in
            comparison to C is its approach to <em>generics</em>. Rust
            uses a technique called "monomorphisation", which simply
            means that each time the Rust compiler instantiates a
            generic function it emits a fresh, optimized, copy of the
            machine code. This creates fast code, but also results in
            large binary sizes that C programmers are unaccustomed
            to.</p>

            <p>C also provides some unique features that might not be
            used often, but occasionally are used to achieve
            performance, things like setjmp/longjmp, and computed
            goto. It's not clear whether Rust would adopt such
            features to gain parity.</p>
          </aside>
        </section>

        <section id="SUC1">
          <h3>Why Rust will succeed</h3>
          <ul>
            <li>Incredible tech</li>
            <li>Production focus</li>
          </ul>

          <aside class="notes">
            <p>So there definitely are some challenges, and it's going to be a long
            road for Rust, but they are surmountable. And we have a lot of reason
            to be hopeful.</p>

            <p>Perhaps the greatest reason is that
            Rust's <em>technical foundations</em> are very, very
            strong. The runtimeless ownership model is a powerful base
            to build the entire computing stack on top of. We are
            <em>thankful</em> every week that, through some miracle,
            all the years of design work we did somehow left us in a
            real <em>sweet spot in the design space</em>.</p>

            <p>And having this strong technical foundation gives us
            <em>freedom</em> to focus on getting Rust
            into <em>production</em> in more places. From the very
            beginning, Rust has been <em>designed for production</em>,
            to fulfill the needs of Firefox, a product used by 100
            million people. And now we are in a position where if we
            just keep knocking down obstacles to production
            deployment, Rust will see wider and wider use. Our
            published <em>roadmap for 2017</em> is almost entirely
            about clearing the way for production users.</p>
          </aside>
        </section>

        <section id="SUC2">
          <h3>Why Rust will succeed</h3>
          <ul>
            <li>Flexible ecosystem design</li>
          </ul>

          <aside class="notes">
            <p>Another major systemic advantage we have built into
            Rust is the design of its <em>library ecosystem</em>, and the
            <em>separation between the language and the
            libraries</em>. Rust is quite modular, with much of its
            capabilities being provided by libraries. <em>For example,
            Rust knows nothing about concurrency</em>, but its
            libraries leverage ownership and borrowing to provide very
            robust and foolproof concurrency abstractions.</p>

            <p>The Rust <em>standard library itself is quite small</em>,
            providing core data structures and operating system
            abstractions. Everything else is provided via Rust's
            package manager <em>Cargo and the library
            ecosystem</em>. This was a very intentional decision to
            ensure both a high quality <em>core product</em>, and to
            encourage <em>free and rapid experimentation</em> in the
            Rust community, and it has paid off well - we see great
            libraries coming out of the Rust community, and as they
            mature they will be adopted into the Rust canon.</p>
          </aside>
        </section>

        <section id="SUC3">
          <h3>Why Rust will succeed</h3>
          <ul>
            <li>Expanded systems audience</li>
            <li>Strong culture</li>
          </ul>

          <aside class="notes">
            <p>The convenience, flexibility, and robustness of the Rust
            system is additionally going to vastly <em>expand the
            audience of systems programmers</em>.</p>

            <p><em>With Rust, systems programming is easy and
            accessible.</em></p>

            <p>This is one of the biggest <em>revelations</em> we've had
            in Rust's development - that <em>there are vast audiences
            that want to write low level code but don't want to write
            C and C++</em>. We see a lot of young programmers with
            backgrounds in Ruby and JavaScript getting into Rust, and
            creating their own high-performance systems software for
            the first time.</p>

            <p>And this points to Rust's greatest strength - it's
            <em>culture and community</em>.</p>

            <p><em>In Rust we are building a new systems
            programming culture, and it is going to be expansive and
            welcoming and accessible, and it is going to change the
            nature of systems programming for the better.</em></p>
          </aside>
        </section>

        <section id="NEXT">
          <h3>What's coming up in Rust?</h3>
          <ul>
            <li class="fragment">Improved ergonomics</li>
            <li class="fragment">`tokio` &#x2000; <span>(really fast async I/O)</span></li>
            <li class="fragment">Docs &#x2000; <span>(reference, APIs, guidelines)</span></li>
            <li class="fragment">Tooling &#x2000; <span>(IDEs, embedded)</span></li>
            <li class="fragment">Language interop &#x2000; <span>(incl. JS, Ruby, C++)</span></li>
          </ul>

          <aside class="notes">
            <p>There's a lot going on in Rust, but let's talk about a
            few of the big things.</p>

            <p>(next)</p>

            <p>The most important thing we are doing right now is
            improving Rust's <em>erogomics</em>. Rust is a very
            powerful system, but it has some <em>rough edges</em>, and
            those especially impact <em>new users</em>. There are a
            number of changes coming up that will make Rust even more
            fun to use than it is today.</p>

            <p>(next)</p>

            <p>The next big thing is <em>asynchronous I/O</em>, via a
            project called "<em>tokio</em>".  Async I/O is how you do
            fast I/O in the modern world. If you are familiar with
            node.js with it's callbacks, that's async I/O. We are
            hopeful that tokio is going to become the <em>fastest and
            most robust async I/O stack</em> there is. This is going
            to be a big <em>enabler</em> for Rust developers, and we
            expect to see some impressive software built on it. <em>Alex
            is giving a talk on this tomorrow</em>.</p>

            <p>(next)</p>

            <p>In Rust we value <em>documentation</em>. Already, we
            hear a lot of praise for the quality of our docs, but
            we're not going to let up. In the next year we'll be
            publishing a completed <em>language reference</em>,
            thoroughly documenting all the most important Rust
            <em>libraries</em>, and proving guidance on designing APIs
            the Rust way.</p>

            <p>(next)</p>

            <p>A programming language is <em>not competitive</em>
            today unless it has strong tooling. Developers have high
            expectations. We're creating a new program called
            the <em>Rust Language Server</em>, an IDE-agnostic server
            that provides the metadata and analysis required to
            fulfill the typical functionality of an IDE. And we're
            integrating that with <em>Visual Studio Code</em>.</p>

            <p>That's going to be released this summer.</p>

            <p>(next)</p>

            <p>Finally, I've already spoken about the importance of
            <em>interop</em>, but it's not just with C and
            C++. Because Rust has no runtime, it's easy to <em>embed
            in any language stack</em>, and we see a lot of demand for
            that.  When you have a Rails application that needs to be
            accelerated, and your choices are memory-unsafe C, and
            Rust, that choice should be easy. We think this is
            a <em>major avenue for Rust adoption</em>.</p>
          </aside>
        </section>

        <section id="FUT" class="noid">

          <aside class="notes">
            <p>
            But that's just what <em>we're</em> doing to enable Rust
            <em>developers</em>. What's really going to happen over
            the next few years is that a lot of <em>world-class</em>
            software is going to be <em>written in Rust</em>. And that
            software is going to be <em>reliable, reusable, and
            maintainable</em> in ways that software written in
            memory-unsafe languages is not. These programs are going
            to enjoy <em>significant advantages</em> over their
            competition, and it will become increasingly <em>difficult
            to choose C and C++ over Rust.</em></p>

            The <em>legacy of C and C++</em> will continue for many
            decades, but <em>the future is in safety</em>. And <em>the
            future is written in Rust</em>.
          </aside>
        </section>

        <!-- Outroduction -->

	<section id="FIN" style="height: 100%;">
          <img src="images/rust-logo-white.svg"
               style="height: 50%;">
          <div id="nametable">
            <div>Brian Anderson<br><small>&lt;banderson@mozilla.com&gt;</small></div>
            <div>Alex Crichton<br><small>&lt;acrichton@mozilla.com&gt;</small></div>
          </div>

          <aside class="notes">
            <p>Once again my name is Brian Anderson, and this is my friend Alex
            Crichton, and this is The End of Unsafety.</p>

            <p>Thank you.</p>
          </aside>
        </section>

        <section id="END" class="noid">
          <h1>The End of Unsafety</h1>
          <img src="images/rust-logo-white.svg">
          <p>https://github.com/brson/the-end-of-unsafety</p>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="js/eou.js"></script>

  </body>
</html>
